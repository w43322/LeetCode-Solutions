# 子序列宽度之和

&emsp;&emsp;[源码](./solution.cpp)

&emsp;&emsp;首先把问题转化一下, 原问题是: 对于每个 _子序列_ 的 _最大值与最小值之差_ 求和. 即:

$$\sum_{子序列i}^{所有子序列}(i中最大值 - i中最小值)$$

$$= \sum_{子序列i}^{所有子序列}i中最大值 - \sum_{子序列i}^{所有子序列}i中最小值$$

&emsp;&emsp;不妨这样考虑: 对于每个数字而言, 我们只需要知道 _这个数字_ 是 _多少个_ 包含它的子序列的 _最大值以及最小值_, 再把 _每个数字_ 与 _相应的子序列的数目_ 的 _乘积_ 求和, 即为所求.

&emsp;&emsp;即把上面公式转化为:

$$\sum_{k}^{nums} \left( k * \sum_{子序列i}^{所有子序列}f(i, k) \right) - \sum_{k}^{nums} \left( k * \sum_{子序列i}^{所有子序列}g(i, k) \right)$$

&emsp;&emsp;其中,

$$f(i, k) = bool(k是子序列i中的一个元素 \land k是子序列i中的最大值)$$

$$g(i, k) = bool(k是子序列i中的一个元素 \land k是子序列i中的最小值)$$

&emsp;&emsp;现在的问题是, 如何确定一个数字 $k$ 是多少个子序列中的最大值或者最小值?

&emsp;&emsp;要解决这个问题, 首先我们可以考虑一个数字 $k$ 比数组中多少个数字大. 假设它比数组中 $m$ 个数字大, 那么令 $k$ 为最大值的子序列数目其实就是 $C(m, m) - 1$, 也就是比他小的数字任意组合, 除去空集. 这个数字也就是 $2^{m} - 1$, 求最小值的子序列数目同理.

&emsp;&emsp;因此在排序后, 下面式子的值即为所求.

$$\sum_{i = 0}^{n - 1} nums[i] * (2^{i} - 1) - \sum_{i = 0}^{n - 1} nums[i] * (2^{n - i - 1} - 1)$$

&emsp;&emsp;因此问题就变得很明朗, 首先用 $O(n)$ 的时间复杂度预处理出 $2^i$, 然后对数组进行排序, 再遍历数组中的每一个数字. 通过它的 $index$, 易得数组中有多少个元素比它大或小, 然后再用上面的公式在 $mod$ $M$ 意义下求和即可.

&emsp;&emsp;总体时间复杂度是 $O(nlogn)$, 瓶颈在于排序.

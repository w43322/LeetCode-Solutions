# 第K个语法符号

&emsp;&emsp;[源码](./solution.c)

&emsp;&emsp;先把表列出来:

|n  |str|
|:-:|:-|
|1  |`0`|
|2  |`01`|
|3  |`0110`|
|4  |`01` `10` `10` `01`|
|5  |`0110` `1001` `1001` `0110`|
|6  |`01101001` `10010110` `10010110` `01101001`|
|`...`|`0110100110010110` `1001011001101001` `...` `...`|

&emsp;&emsp;通过观察发现, 每一行的前一半都和上一行完全相同, 而每一行的 $\frac{1}{2}$ 处到 $\frac{3}{4}$ 处与自身的 $\frac{1}{4}$ 处到 $\frac{1}{2}$ 处又相同, 同时, 每一行的后 $\frac{1}{4}$ 与自身的前 $\frac{1}{4}$ 也相同.

&emsp;&emsp;因此, 如果 $k$ 的位置大于当前串的后半段, 只需要把它映射到该串的前半段, 然后再递归地返回上一个串的该位置即可. 该算法时间复杂度为 $O(n)$, 空间复杂度为 $O(n)$.

&emsp;&emsp;进一步观察发现, 所求的结果其实跟 $n$ 无关, 只与 $k$ 有关. 该问题的结果总是 $k - 1$ 的二进制表示中 $1$ 的个数, 对 $2$ 取模. 该算法的时间复杂度为 $O(logk)$, 空间复杂度为 $O(1)$.

&emsp;&emsp;实际实现的时候发现, 使用老版本GCC(8.2, target=x86-64)自带的`__builtin_popcount`函数运行较慢. 显然, 一个二进制串中 $1$ 的个数对 $2$ 取模实际上就是该串中所有数字按位异或, 因此可以改写成循环加异或运算的形式, 降低 runtime.
